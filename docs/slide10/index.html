<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/github.css" />

    <link rel="stylesheet" href="./assets/custom.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="\r?\n---\r?\n" data-separator-vertical="\r?\n----\r?\n">
          <textarea data-template>
            # Lập trình hướng đối tượng OOP

---

## TIết 1: OPP - Tính đóng gói
### Mục tiêu
- Kiến thức: Hiểu các khái niệm Lớp, Đối tượng, Thuộc tính, Phương thức và ý nghĩa Tính Đóng Gói.
- Kỹ năng: Phân tích Class đơn giản, viết Class nhỏ, tạo đối tượng và sử dụng thuộc tính, phương thức.
- Tư duy: Hình thành tư duy lập trình có cấu trúc.

---

## Đặt vấn đề

<div class="split-2">

<div class="column">

```python
{
  "main": {
    "temp": 300.15,
    "feels_like": 302.45,
    "pressure": 1010,
    "humidity": 75
  }
}
```

</div>

<div class="column">

- Đọc nhiệt độ và độ ẩm ?
- Cách viết này có nhược điểm gì
- <mark>Làm thế nào để gọn gàng hơn?</mark>

</div>

</div>

---

<div>

## Khái niệm lập trình OPP
### Class , Object

<div class="split-2">
<div class="column fragment">

**Class (Lớp)**: Xem như bản thiết kế chiếc xe
!['car.png'](images/car.png)

</div>

<div class="column fragment">

**Object (Đối tượng hay thể hiện)**:  Thể hiện của lớp: xe đua , xe bán tải...
!['car1.png'](images/car1.png)

</div>
</div>

</div>

---

## Atrribute , Method

<div class="split-2">
<div class="column fragment">

**Attribute (Thuộc tính)**: 
Đặc điểm của xe
- Giá tiền
- Màu săc
- Động cơ

</div>
<div class="column fragment">

**Method (Phương thức)**:
Phương thức tác động lên chiếc xe
- Tăng tốc (đạp ga)
- Giảm tốc (Thắng xe)
- Phát ra còi
- Điều hướng (thẳng, trái,phải ...)

</div>
</div>

---

<div>

## Tính đóng gói
Gom tất cả những thứ liên quan (thuộc tính và phương thức) vào chung một "cái hộp" là Class
<div class="split-2">
<div class="column">

!["mouse.png"](images/mouse.png)

</div>

<div class="column">

- **class Mouse**  
- **Thuộc tính**   
  - Nút chuột trái  <!-- .element: class="fragment" -->
  - Nút chuột phải  <!-- .element: class="fragment" -->
- **Phương thức**   
  - Nhấn chuột trái <!-- .element: class="fragment" -->
  - Di chuyển chuột <!-- .element: class="fragment" -->

</div>
</div>
</div>

---

## Minh họa cách khởi tạo class

```python
def __init__(self, open_weather_data): 
  main_data = open_weather_data.get('main', {})
  temp_k = main_data.get('temp','N/A')
  self.temperature_c = self.k_to_c(temp_k)
```
<!-- .element: class="fragment" -->

```python
def k_to_c(self,temp_k):
  if isinstance(temp_k, (int, float)):
    return round(temp_k - 273.15, 1)
  return 'N/A'
```
<!-- .element: class="fragment" -->

```python
def __str__(self):
  output += f"Nhiệt độ: {self.temperature_c}°C\n"
  return output
```
<!-- .element: class="fragment" -->

---

## Một vài phương thức mặc định của lớp
- Phương thức ```__init___``` là hàm đặc biệt để khởi tạo lớp. Sẽ được gọi khi tạo thể hiện của lớp
- Phương thức ```__repr__()```: Phương thức này sẽ được gọi khi dùng hàm `print(...)` lên đối đối tượng
- Phương thức ```__str__()```:  Phương thức này sẽ được gọi khi dùng hảm `str(...)` lên đối tượng
- Ngoài ra còn nhiều phwuong thức đặc biệt khác: 
[A Guide to Python’s Magic Methods](https://rszalski.github.io/magicmethods/)

---

## Live code
- Bước 1: Tạo dữ liệu giả lập thời tiết
```python
sample_data = {"main": {"temp": 298.15, "humidity": 80}}
```
<!-- .element: class="fragment" -->

- Bước 2: Tạo đối tượng thời tiết
```python
weather_bmt = My_Weather(sample_data)
```
<!-- .element: class="fragment" -->

- Bước 3: Gọi phương thưc lấy thông tin
```python
print(f"Nhiệt độ: {weather_bmt.temperature_c}°C") 
```
<!-- .element: class="fragment" -->

---

## Bài tập thực hành
Nhiệm vụ : **Tạo một Class tên là Sensor để mô tả một cảm biến**
- **Tên Class**: <mark>Sensor</mark>.
-	**Khởi tạo với 3 tham số đầu vào**: <mark>name, value, unit.</mark>
- **Các thuộc tính**: <mark> self.name, self.value, self.unit. </mark>
- **Phương thức**: <mark>display()</mark>: In ra thông tin cảm biến theo định dạng, ví dụ: "Cảm biến Nhiệt độ: 35.5 °C".

---

## TIết 2: OPP - Tính kế thừa

### Mục tiêu
- Kiến thức: 
  - Hiểu Kế thừa, Lớp Cha, Lớp Con. 
  - Hiểu Overriding và cách dùng super().
- Kỹ năng: 
  - Đọc hiểu và phân tích được cấu trúc kế thừa trong code dự án. 
- Tư duy: 
  - Hình thành tư duy tái sử dụng, tránh lặp lại code 

---
<div>

## Tình huống 1

<div class="split-3">

<div class="column">
<p class="s2">Wifi and LCD</p>

!["hinh_2_1.png"](images/hinh2_1.png)

</div>

<div class="column">
<p class="s2">MyDevice</p>

!["hinh_2_2.png"](images/hinh2_2.png)

</div>

<div class="column">
<p class="s2">Thiết kế</p>

!["hinh_2_3.png"](images/hinh2_3.png)

</div>
</div>
<mark>Làm sao ta có thể tái sử dụng module dựng sẵn?</mark>

</div>

---
## Tình huống 2:
Giả sử chúng ta viết đơn lẻ như sau

```python
class FanData:
    def __init__(self, id, value, timestamp):
        self.id = id
        self.value = value
        self.timestamp = timestamp
```

```python
class PumpData:
    def __init__(self, id, value, timestamp):
        self.id = id
        self.value = value
        self.timestamp = timestamp
```
<mark>Làm sao ta có thể tránh lặp điểm chung?</mark>

---

## Khái niệm tính kế thừa
### Tính kế thừa
- Là cơ chế cho phép một Lớp (gọi là <mark>Lớp Con</mark> - Child Class) **thừa hưởng** lại toàn bộ thuộc tính và phương thức từ một Lớp khác (gọi là <mark>lớp Cha</mark> - Parent Class).
- Mục đích chính : Tái sử dụng code

---

### Ghi đè phương thức (Method Overriding)
- Khi Lớp Con <mark>định nghĩa</mark> lại một phương thức đã có sẵn ở Lớp Cha, hành động đó gọi là ghi đè.
- Mục đích: Giúp Lớp Con có thể tùy biến, <mark>chuyên biệt hóa hành vi</mark> của mình. 
- Ví dụ: Cùng là ```__repr__``` nhưng FanData sẽ hiển thị chữ "Fan", còn PumpData hiển thị chữ "Pump".

---

### Hàm ```supper()```
- Là một hàm đặc biệt dùng để gọi đến các phương thức của Lớp Cha từ bên trong Lớp Con.
- Rất hay được dùng trong ```__init__``` của Lớp Con để <mark>"nhờ"</mark> Lớp Cha thực hiện phần khởi tạo các thuộc tính chung.
- ```__init___``` là hàm đặc biệt để khởi tạo lớp.

---

### Minh họa về kế thừa
Khai báo lớp cha

```python s1
class RelayData:
    def __init__(self, id, value,timestamp):
        self.id = id
        self.value = value
        self.timestamp = timestamp
    def __repr__(self):
        return f"RelayData id={self.id}, value={self.value}, timestamp={self.timestamp}"
```
<!-- .element: class="fragment" -->

Khai báo lớp con

```python s1
class FanData(RelayData):
    def __init__(self, id, value,timestamp):
        super().__init__(id,value,timestamp)
    def __repr__(self):
        return f"FanData id={self.id}, value={self.value},timestamp={self.timestamp}"
```
<!-- .element: class="fragment" -->

---

### Bài tập thực hành
- Nhiệm vụ : Xây dựng lớp PumpData với yêu cầu sau
  - <mark>Tên Class</mark>: PumpData.
  -	<mark>Kế thừa lớp RelayData</mark>
  - <mark>Nhận vào 3 thuộc tính: id, value, timestamp
  - <mark>Phương thức ```__repr__()```</mark>: override phương thức ```__repr__()``` của lớp cha với định dạng
  ```f"PumbData id=..., value=...,timestamp=..."```

---

## Tiết 3: OPP tính đa hình
### Đặt vấn đề
- Bây giờ, hãy tưởng tượng  chúng ta có một danh sách tất cả các thiết bị : Bơm , Quạt  kế thừa từ lớp Relay
- Chúng ta muốn viết **MỘT chức năng duy nhất** để in trạng thái của từng thiết bị. 
- Chẳng lẽ chúng ta phải viết code kiểm tra: if thiết bị là Quạt thì làm thế này, if thiết bị là Bơm thì làm thế kia? 
- <mark>Để giải quyết ta dùng khái niệm tính đa hình </mark>

---

### Khái niệm tính đa hình (Polymorphism)
- "Poly" nghĩa là "nhiều", "Morph" là "hình thái". Đa hình là khả năng một hàm hoặc một đối tượng có thể xử lý nhiều kiểu đối tượng khác nhau như thể chúng là một.
- Nguyên tắc cốt lõi: <mark>"Chỉ cần 'nói chuyện' với Lớp Cha, có thể điều khiển được tất cả các Lớp Con."</mark>

---

### Minh họa tính đa hình
```python
# Giả sử đã có các class RelayData, FanData, PumpData
fan1 = FanData(1, 'ON', '2025-10-23 19:00:00')
pump1 = PumpData(2, 'OFF', '2025-10-23 19:05:00')
```

```python
# Xây dựng hàm báo cáo trạng thái thiết bị
def display_status(device:RelayData):
    print("--- Báo cáo trạng thái thiết bị ---")
    print(device)
```

```python
# Quan sát kết quả khi gọi hàm
display_status(fan1)
display_status(pump1)
```
---

### Bài tập thực hành
- Tạo thêm <mark>class HeaterData</mark> kế thừa từ **RelayData**.
- Thêm thuộc tính <mark>temperature</mark> (nhiệt độ hiện tại của thiết bị).
- <mark>Ghi đè phương thức</mark> ```__repr__()``` để hiển thị: "Heater {id}, trạng thái: {status}, nhiệt độ: {temperature}".
- Gọi hàm `display_status()` ở trên để kiểm tra

---

# Thank You








          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"_":["slide10/slide10.md"],"static":"docs/slide10","config":"reveal-md.json","static-dirs":"slide10/images","staticDirs":"slide10/images"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
